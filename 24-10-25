
ğŸŒ³ Dayâ€™s Work â€” Validate a Binary Search Tree (BST)
ğŸ§© Problem

Check whether a given binary tree is a valid Binary Search Tree (BST).
A BST must follow:

Left subtree nodes < root node

Right subtree nodes > root node

Both subtrees must themselves be BSTs

ğŸ’¡ Approach

Used a recursive range validation technique:

Each node must satisfy (lowerbound < node->val < upperbound)

Left subtree updates upperbound = root->val

Right subtree updates lowerbound = root->val

Used long long limits (LLONG_MIN, LLONG_MAX) to handle extreme cases safely.

ğŸ§¾ Code
#include <climits>

class Solution {
public:
    bool solve(TreeNode* root, long long lowerbound, long long upperbound) {
        if (root == NULL)
            return true;

        bool cond1 = (root->val > lowerbound);
        bool cond2 = (root->val < upperbound);

        bool leftans = solve(root->left, lowerbound, root->val);
        bool rightans = solve(root->right, root->val, upperbound);

        return (cond1 && cond2 && leftans && rightans);
    }

    bool isValidBST(TreeNode* root) {
        long long lowerbound = LLONG_MIN;
        long long upperbound = LLONG_MAX;
        return solve(root, lowerbound, upperbound);
    }
};

ğŸ•’ Time Complexity

O(N) â€” Each node is visited once.

ğŸ’¾ Space Complexity

O(H) â€” Recursion stack (where H = height of tree).

âœ… Learning Outcome

Understood the importance of maintaining range bounds in recursive BST validation.

Learned how integer overflow can occur with INT_MIN and INT_MAX, and why to use LLONG_MIN / LLONG_MAX.

Reinforced concepts of recursion, BST properties, and boundary conditions.

ğŸ“… Commit Message Example
âœ… Day 24: Implemented â€œValidate BSTâ€ using recursive bounds approach in C++
